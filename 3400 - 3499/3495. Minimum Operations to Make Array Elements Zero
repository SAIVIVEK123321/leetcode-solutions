---
comments: true
difficulty: Hard
edit_url: https://github.com/SAIVIVEK123321/LeetCode_Problems/edit/main/2701-2800/2749.Minimum%20Operations%20to%20Make%20the%20Integer%20Zero/README.md
rating: 2100
source: LeetCode Problem 2749
tags:
    - Bit Manipulation
    - Math
    - Greedy
---

<!-- problem:start -->

# [2749. Minimum Operations to Make the Integer Zero](https://leetcode.com/problems/minimum-operations-to-make-the-integer-zero/)

## Problem Statement

You are given two integers `num1` and `num2`.

In one operation, you can choose an integer `i` in the range `[0, 60]` and subtract `2^i + num2` from `num1`.

Return the minimum number of operations needed to make `num1` equal to `0`.  
If it is impossible, return `-1`.

---

## Example 1

**Input:**
num1 = 3, num2 = -2

**Output:**

**Explanation:**
- Choose i = 2 → 3 - (4 + (-2)) = 1  
- Choose i = 2 → 1 - (4 + (-2)) = -1  
- Choose i = 0 → -1 - (1 + (-2)) = 0  

Minimum operations = 3.

---

## Example 2

**Input:**
-1

**Explanation:**
It is impossible to make 5 equal to 0.

---

## Constraints

- `1 <= num1 <= 10^9`
- `-10^9 <= num2 <= 10^9`

---

## Solutions

### Python3
```python
class Solution:
    def makeTheIntegerZero(self, num1: int, num2: int) -> int:
        curr = num1 - num2
        x = 1
        while curr > 0:
            b = bin(curr).count("1")
            if x >= b:
                if x != 1 and curr == 1:
                    return -1
                return x
            x += 1
            curr = num1 - x * num2
        return -1

#### Python3

```python
class Solution:
    def minOperations(self, queries: List[List[int]]) -> int:
        def f(x: int) -> int:
            res = 0
            p = i = 1
            while p <= x:
                cnt = min(p * 4 - 1, x) - p + 1
                res += cnt * i
                i += 1
                p *= 4
            return res

        ans = 0
        for l, r in queries:
            s = f(r) - f(l - 1)
            mx = f(r) - f(r - 1)
            ans += max((s + 1) // 2, mx)
        return ans
```

#### Java

```java
class Solution {
    public long minOperations(int[][] queries) {
        long ans = 0;
        for (int[] q : queries) {
            int l = q[0], r = q[1];
            long s = f(r) - f(l - 1);
            long mx = f(r) - f(r - 1);
            ans += Math.max((s + 1) / 2, mx);
        }
        return ans;
    }

    private long f(long x) {
        long res = 0;
        long p = 1;
        int i = 1;
        while (p <= x) {
            long cnt = Math.min(p * 4 - 1, x) - p + 1;
            res += cnt * i;
            i++;
            p *= 4;
        }
        return res;
    }
}
```

#### C++

```cpp
class Solution {
public:
    long long minOperations(vector<vector<int>>& queries) {
        auto f = [&](long long x) {
            long long res = 0;
            long long p = 1;
            int i = 1;
            while (p <= x) {
                long long cnt = min(p * 4 - 1, x) - p + 1;
                res += cnt * i;
                i++;
                p *= 4;
            }
            return res;
        };

        long long ans = 0;
        for (auto& q : queries) {
            int l = q[0], r = q[1];
            long long s = f(r) - f(l - 1);
            long long mx = f(r) - f(r - 1);
            ans += max((s + 1) / 2, mx);
        }
        return ans;
    }
};
```

#### Go

```go
func minOperations(queries [][]int) (ans int64) {
	f := func(x int64) (res int64) {
		var p int64 = 1
		i := int64(1)
		for p <= x {
			cnt := min(p*4-1, x) - p + 1
			res += cnt * i
			i++
			p *= 4
		}
		return
	}
	for _, q := range queries {
		l, r := int64(q[0]), int64(q[1])
		s := f(r) - f(l-1)
		mx := f(r) - f(r-1)
		ans += max((s+1)/2, mx)
	}
	return
}
```

#### TypeScript

```ts
function minOperations(queries: number[][]): number {
    const f = (x: number): number => {
        let res = 0;
        let p = 1;
        let i = 1;
        while (p <= x) {
            const cnt = Math.min(p * 4 - 1, x) - p + 1;
            res += cnt * i;
            i++;
            p *= 4;
        }
        return res;
    };

    let ans = 0;
    for (const [l, r] of queries) {
        const s = f(r) - f(l - 1);
        const mx = f(r) - f(r - 1);
        ans += Math.max(Math.ceil(s / 2), mx);
    }
    return ans;
}
```

#### Rust

```rust
impl Solution {
    pub fn min_operations(queries: Vec<Vec<i32>>) -> i64 {
        let f = |x: i64| -> i64 {
            let mut res: i64 = 0;
            let mut p: i64 = 1;
            let mut i: i64 = 1;
            while p <= x {
                let cnt = std::cmp::min(p * 4 - 1, x) - p + 1;
                res += cnt * i;
                i += 1;
                p *= 4;
            }
            res
        };

        let mut ans: i64 = 0;
        for q in queries {
            let l = q[0] as i64;
            let r = q[1] as i64;
            let s = f(r) - f(l - 1);
            let mx = f(r) - f(r - 1);
            ans += std::cmp::max((s + 1) / 2, mx);
        }
        ans
    }
}
```

<!-- tabs:end -->

<!-- solution:end -->

<!-- problem:end -->
