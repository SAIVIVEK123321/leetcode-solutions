---
comments: true
difficulty: Medium
edit_url: https://github.com/SAIVIVEK123321/leetcode-solutions/edit/main/solution/3000-3099/3025.Find%20the%20Number%20of%20Ways%20to%20Place%20People%20I/README_EN.md
rating: 1707
source: Biweekly Contest 123 Q2
tags:
    - Geometry
    - Array
    - Math
    - Enumeration
    - Sorting
---

<!-- problem:start -->

# [3025. Find the Number of Ways to Place People I](https://github.com/SAIVIVEK123321/leetcode-solutions/blob/main/solution/3000-3099/3025.Find%20the%20Number%20of%20Ways%20to%20Place%20People%20I/README_EN.md)

[中文文档](https://github.com/SAIVIVEK123321/leetcode-solutions/blob/main/solution/3000-3099/3025.Find%20the%20Number%20of%20Ways%20to%20Place%20People%20I/README.md)

## Description

You are given a 2D array `points` of size `n x 2` representing integer coordinates of some points on a 2D plane, where `points[i] = [xᵢ, yᵢ]`.

Count the number of pairs of points `(A, B)` such that:

- `A` is on the **upper left** side of `B`, and  
- there are no other points in the rectangle (or line) they form (**including the border**).

Return the count.

---

### Example 1:

**Input:**  
`points = [[1,1],[2,2],[3,3]]`  

**Output:**  
`0`  

**Explanation:**  
No valid way to choose `(A, B)` with `A` upper-left of `B` and an empty rectangle.

---

### Example 2:

**Input:**  
`points = [[6,2],[4,4],[2,6]]`  

**Output:**  
`2`  

**Explanation:**  
- `(points[1], points[0])` is valid.  
- `(points[2], points[1])` is valid.  
- `(points[2], points[0])` is invalid since `points[1]` lies inside the rectangle.

---

### Example 3:

**Input:**  
`points = [[3,1],[1,3],[1,1]]`  

**Output:**  
`2`  

**Explanation:**  
- `(points[2], points[0])` is valid.  
- `(points[1], points[2])` is valid.  
- `(points[1], points[0])` is invalid because `points[2]` lies on the rectangle border.

---

## Constraints

- `2 <= n <= 50`  
- `points[i].length == 2`  
- `0 <= points[i][0], points[i][1] <= 50`  
- All `points[i]` are distinct  

---

## Solutions

### Approach: Sorting and Enumeration

1. Sort points by **ascending x-coordinate**, and if x is the same, by **descending y-coordinate**.  
2. For each point `i`, consider all later points `j` (with larger x).  
3. Track the current maximum y-value `maxY`; if `y₂` satisfies `maxY < y₂ <= y₁`, count the pair and update `maxY`.

This correctly counts pairs where no other point obstructs the rectangle (inclusive of the border).

- **Time Complexity:** `O(n²)` (sufficient for `n ≤ 50`)  
- **Space Complexity:** `O(1)`

---

#### Python 3

```python
class Solution:
    def numberOfPairs(self, points: List[List[int]]) -> int:
        points.sort(key=lambda x: (x[0], -x[1]))
        ans = 0
        for i, (_, y1) in enumerate(points):
            maxY = -float("inf")
            for _, y2 in points[i + 1:]:
                if maxY < y2 <= y1:
                    maxY = y2
                    ans += 1
        return ans
#### Java

```java
class Solution {
    public int numberOfPairs(int[][] points) {
        Arrays.sort(points, (a, b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);
        int ans = 0;
        int n = points.length;
        final int inf = 1 << 30;
        for (int i = 0; i < n; ++i) {
            int y1 = points[i][1];
            int maxY = -inf;
            for (int j = i + 1; j < n; ++j) {
                int y2 = points[j][1];
                if (maxY < y2 && y2 <= y1) {
                    maxY = y2;
                    ++ans;
                }
            }
        }
        return ans;
    }
}
```

#### C++

```cpp
class Solution {
public:
    int numberOfPairs(vector<vector<int>>& points) {
        sort(points.begin(), points.end(), [](const vector<int>& a, const vector<int>& b) {
            return a[0] < b[0] || (a[0] == b[0] && b[1] < a[1]);
        });
        int n = points.size();
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            int y1 = points[i][1];
            int maxY = INT_MIN;
            for (int j = i + 1; j < n; ++j) {
                int y2 = points[j][1];
                if (maxY < y2 && y2 <= y1) {
                    maxY = y2;
                    ++ans;
                }
            }
        }
        return ans;
    }
};
```

#### Go

```go
func numberOfPairs(points [][]int) (ans int) {
	sort.Slice(points, func(i, j int) bool {
		return points[i][0] < points[j][0] || points[i][0] == points[j][0] && points[j][1] < points[i][1]
	})
	for i, p1 := range points {
		y1 := p1[1]
		maxY := math.MinInt32
		for _, p2 := range points[i+1:] {
			y2 := p2[1]
			if maxY < y2 && y2 <= y1 {
				maxY = y2
				ans++
			}
		}
	}
	return
}
```

#### TypeScript

```ts
function numberOfPairs(points: number[][]): number {
    points.sort((a, b) => (a[0] === b[0] ? b[1] - a[1] : a[0] - b[0]));
    const n = points.length;
    let ans = 0;
    for (let i = 0; i < n; ++i) {
        const [_, y1] = points[i];
        let maxY = -Infinity;
        for (let j = i + 1; j < n; ++j) {
            const [_, y2] = points[j];
            if (maxY < y2 && y2 <= y1) {
                maxY = y2;
                ++ans;
            }
        }
    }
    return ans;
}
```

#### Rust

```rust
impl Solution {
    pub fn number_of_pairs(mut points: Vec<Vec<i32>>) -> i32 {
        points.sort_by(|a, b| {
            if a[0] == b[0] {
                b[1].cmp(&a[1])
            } else {
                a[0].cmp(&b[0])
            }
        });

        let n = points.len();
        let mut ans = 0;
        for i in 0..n {
            let y1 = points[i][1];
            let mut max_y = i32::MIN;
            for j in (i + 1)..n {
                let y2 = points[j][1];
                if max_y < y2 && y2 <= y1 {
                    max_y = y2;
                    ans += 1;
                }
            }
        }
        ans
    }
}
```

#### C#

```cs
public class Solution {
    public int NumberOfPairs(int[][] points) {
        Array.Sort(points, (a, b) => a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);
        int ans = 0;
        int n = points.Length;
        int inf = 1 << 30;
        for (int i = 0; i < n; ++i) {
            int y1 = points[i][1];
            int maxY = -inf;
            for (int j = i + 1; j < n; ++j) {
                int y2 = points[j][1];
                if (maxY < y2 && y2 <= y1) {
                    maxY = y2;
                    ++ans;
                }
            }
        }
        return ans;
    }
}
```

<!-- tabs:end -->

<!-- solution:end -->

<!-- problem:end -->
